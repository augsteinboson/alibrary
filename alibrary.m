(* # Amplitude library (`alibrary.m`)
 *
 * Tired of relying on large monolitic programs to generate
 * your Feynman amplitudes? What you need is a library: *alibrary*.
 *
 * This file deals with Feynman diagrams and all the related
 * things. Generic Mathematica utils go into [[utils.m]].
 * Tests go into [[atestsuite.m]].
 *
 * ## Contents
 * [[table of contents]]
 *
 * * * *
 *
 * First, load the other libraries, [[utils.m]] and [[library.m]].
 *)

Get["utils.m"];
Get["library.m"];

(*
 * ## Diagrams
 * 
 * We use diagrams generated by QGraf and expect them to come
 * in the following format (defined in `qgraf-stylefile`):
 *
 *     Diagram[id, sym-factor, {in-field ...}, {out-field ...}, {propagator ...}, {vertex ...}]
 *
 * where
 * - id is an arbitrary identified of the diagram;
 * - sym-factor is the symmetry factor and the sign of the diagram;
 * - in- and out-fields: F["field", field-idx, vertex-idx, momentum];
 * - propagators:   P["field", from-field-idx, to-field-idx, from-vertex-idx, to-vertex-idx, momentum]
 * - vertices:      V[vertex-idx, "fields", field-idx-1, momentum-1, field-idx-2, momentum-2, ...]
 *
 * All the information here is directly as QGraf provides it,
 * just packaged into a Mathematica expression.
 *
 * To generate diagrams conveniently, use [[mkdia.py]]. Less
 * convenient is [[qgraf.sh]]. The least conveninet is direct
 * `qgraf` invocation.
 *)

(* Because `Diagram[]` objects are not `Association`s, here are
 * some functions that help access their parts by names, instead
 * of numbers. (In many places we will access these parts by
 * numbers still; arguably those places should be changed to use
 * these functions).
 *)
DiagramId[Diagram[id_, factor_, ifld_, ofld_, props_, verts_]] := id

(* Note that we store but don’t trust the sign of the diagram
 * that QGraf produces. Use [[DiagramSign]] to compute the actual
 * sign.
 *)
DiagramSymmetryFactor[Diagram[_, factor_, _, _, _, _]] := Abs[factor]

DiagramIncomingFields[Diagram[_, _, ifld_List, _, _, _]] := ifld

DiagramOutgoingFields[Diagram[_, _, _, ofld_List, _, _]] := ofld

DiagramPropagators[Diagram[_, _, _, _, props_List, _]] := props

DiagramVertices[Diagram[_, _, _, _, _, verts_List]] := verts

(* Return the number of closed loops comprised only of fields
 * that match the given (string) pattern. Only really works
 * for fields that always come in a pair in each vertex (e.g.
 * fermions).
 *)
DiagramClosedLoops[fieldpat_] := DiagramFieldLoops[#, fieldpat]&
DiagramClosedLoops[Diagram[_, _, i_List, o_List, p_List, _], fieldpat_] :=
Module[{edges, SS, II, EE},
  edges = Join[
    i // Cases[ F[fieldpat, fi_, vi_, _] :> SS[fi] <-> II[vi] ],
    o // Cases[ F[fieldpat, fi_, vi_, _] :> II[vi] <-> EE[fi] ],
    p // Cases[ P[fieldpat, fi1_, fi2_, vi1_, vi2_, _] :> II[vi1] <-> II[vi2] ]
  ];
  edges // ConnectedComponents // Select[FreeQ[_SS|_EE]] // Length
]

(* Compute the sign of a diagram by counting fermion loops.
 *
 * Note that we don’t assume to know the names of all fermion
 * fields, and expect them to be passed in explicitly. The fermion
 * field pattern can be something like `"q"|"Q"|"t"|"T"|"c"|"C"`.
 *)
DiagramSign[d_Diagram, fermionpattern_] := (-1)^DiagramClosedLoops[d, fermionpattern]
DiagramSign[fermionpattern_] := DiagramSign[#, fermionpattern]&

(* ## Diagrams to graphs
 *)

(* Convert a diagram to a list of undirected edges.
 *)
DiagramGraphEdges[Diagram[_, _, i_List, o_List, p_List, _]] := Join[
  p /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> Internal[vi1] <-> Internal[vi2],
  i /. F[f_, fi_, vi_, mom_] :> Incoming[fi] <-> Internal[vi],
  o /. F[f_, fi_, vi_, mom_] :> Internal[vi] <-> Outgoing[fi]
]

(* Convert a diagram to an undirected `Graph` object.
 *)
DiagramGraph[d_Diagram] := DiagramGraphEdges[d] // Graph
DiagramGraph[CutDiagram[d1_Diagram, d2_Diagram]] := Module[{e1, e2, x},
  e1 = DiagramGraphEdges[d1];
  e2 = DiagramGraphEdges[d2];
  Join[
    e1 // DeleteCases[_ <-> _Outgoing],
    e2 /.
      Incoming -> Incoming2 /.
      Internal -> Internal2 /.
      Cases[e1, (i_ <-> e_Outgoing) :> ((x_ <-> e) :> Style[x <-> i, Dashed])]
  ]
]

(* Convert a diagram to an [[XGraph]] object, with informational
 * labels on each edge.
 *)
DiagramXGraph[Diagram[_, _, i_List, o_List, p_List, _]] := Join[
   i /. F[f_, fi_, vi_, mom_] :> {IN[fi] -> vi,
      Text[MkString[f, "(", mom, ")"] // StringReplace[" " -> ""]],
      Gray, Thin},
   o /. F[f_, fi_, vi_, mom_] :> {vi -> OO[fi],
      Text[MkString[f, "(", mom, ")"] // StringReplace[" " -> ""]],
      Gray, Thin},
   p /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> {vi1 -> vi2,
      Text[MkString[f, "(", mom, ")"] // StringReplace[" " -> ""]],
      Switch[f, q, Thickness[0.01], _, {}]}
   ] // XGraph

(* Convert a diagram to a source code for a Graphviz `digraph` object.
 *)
DiagramToGraphviz[Diagram[id_, _, i_List, o_List, p_List, _]] := Module[{c, defc},
  c = <|
    "q" -> 6, "Q" -> 6,
    "t" -> 6, "T" -> 6,
    "g" -> 4,
    "c" -> 8, "C" -> 8,
    "O" -> 10, "H" -> 10, "A" -> 10, "Z" -> 10, "s" -> 10, "S" -> 10
  |>;
  defc = 12;
  MkString[
   "digraph {\n",
   " fontsize=12; margin=0;\n",
   " node [shape=circle width=0.1 color=black];\n",
   " edge [fontsize=8; colorscheme=paired12];\n",
   i /. F[f_, fi_, vi_, mom_] :> fi // Union // Map[{" ", #, " [width=0.05 color=gray];\n"} &],
   o /. F[f_, fi_, vi_, mom_] :> fi // Union // Map[{" ", #, " [width=0.05 color=gray];\n"} &],
   i /. F[f_, fi_, vi_, mom_] :> {
     " ", fi, " -> ", vi,
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"},
   p /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> {
     " ", vi1, " -> ", vi2,
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc], ",style=bold];\n"},
   o /. F[f_, fi_, vi_, mom_] :> {
     " ", vi, " -> ", fi,
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"},
   "}\n"
   ]
]
DiagramToGraphviz[CutDiagram[
  Diagram[id1_, _, i1_List, o1_List, p1_List, v1_List], Diagram[id2_, _, i2_List, o2_List, p2_List, v2_List]
]] := Module[{c, defc},
  c = <|
    "q" -> 6, "Q" -> 6,
    "t" -> 6, "T" -> 6,
    "g" -> 4,
    "c" -> 8, "C" -> 8,
    "O" -> 10, "H" -> 10, "A" -> 10, "Z" -> 10, "s" -> 10, "S" -> 10
  |>;
  defc = 12;
  MkString[
   "digraph {\n",
   " fontsize=12; margin=0; label_scheme=2;\n",
   " node [shape=circle width=0.1 color=black];\n",
   " edge [fontsize=8; colorscheme=paired12];\n",
   i1 /. F[f_, fi_, vi_, mom_] :> fi // Union // Map[{" ", #, "01 [fontsize=10 width=0.05 color=gray label=\"", #, "\"];\n"} &],
   i2 /. F[f_, fi_, vi_, mom_] :> fi // Union // Map[{" ", #, "02 [fontsize=10 width=0.05 color=gray label=\"", #, "'\"];\n"} &],
   v1 /. V[id_, ___] :> id // Union // Map[{" ", #, "01 [label=\"", #, "\"];\n"} &],
   v2 /. V[id_, ___] :> id // Union // Map[{" ", #, "02 [label=\"", #, "'\"];\n"} &],
   o1 /. F[f_, fi_, vi_, mom_] :> fi // Union // Map[{" \"|edgelabel|", -#, "00\" [fontsize=10 width=0.05 shape=square color=gray label=\"", #, "\"];\n"} &],
   i1 /. F[f_, fi_, vi_, mom_] :> {
     " ", fi, "01 -> ", vi, "01",
     "[label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"
   },
   i2 /. F[f_, fi_, vi_, mom_] :> {
     " ", fi, "02 -> ", vi, "02",
     "[label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"
   },
   p1 /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> {
     " ", vi1, "01 -> ", vi2, "01",
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc], ",style=bold];\n"
   },
   p2 /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> {
     " ", vi1, "02 -> ", vi2, "02",
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc], ",style=bold];\n"
   },
   o1 /. F[f_, fi_, vi_, mom_] :> {
     " ", vi, "01 -> \"|edgelabel|", -fi, "00\"",
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"
   },
   o2 /. F[f_, fi_, vi_, mom_] :> {
     " ", vi, "02 -> \"|edgelabel|", -fi, "00\"",
     " [label=\"", f, "(", mom // ToString // StringReplace[" " -> ""], ")\",color=", Lookup[c, f, defc] - 1, "];\n"
   },
   "}\n"
   ]
]

(* Use Graphviz to convert a diagram into a `Graphics` object.
 * Useful for visualization.
 *)
DiagramViz[d:(_Diagram|_CutDiagram)] := Module[{tmp, pdf, result},
  tmp = MkTemp["diavis", ".gv"];
  pdf = tmp <> ".pdf";
  Export[tmp, DiagramToGraphviz[d], "String"];
  Run["neato -Tpdf -o", pdf, tmp];
  result = Import[pdf];
  DeleteFile[{tmp, pdf}];
  result // First
]

(* Convert a diagram into badly layed out TikZ, with the intention
 * to let the user to manually edit the TikZ source afterwards
 * using e.g. [TikZiT].
 *
 * [tikzit]: https://tikzit.github.io/
 *)
DiagramToTikZ[Diagram[id_, _, i_List, o_List, p_List, v_List]] := Module[{es, ni, no, scale},
  es = {
    "q"|"u"|"d"|"c"|"s"|"t"|"b"|"x"|"y" -> "fermion",
    "W"|"A" -> "photon",
    "g" -> "gluon",
    "h" -> "scalar",
    "c" -> "ghost",
    _ -> "edge"
  };
  ni = Length[i];
  no = Length[o];
  scale = Max[ni,no,4];
  MkString[
    "\\begin{tikzpicture}\n",
    "\t\\begin{pgfonlayer}{nodelayer}\n",
    i /. F[f_, fi_, vi_, mom_] :> {"\t\t\\node [style=blank] (", fi, ") at (0, ", scale(-1-fi)/(2 ni)//Round, ") {$", f, "(", mom, ")$};\n"},
    o /. F[f_, fi_, vi_, mom_] :> {"\t\t\\node [style=blank] (", fi, ") at (", scale, ", ", scale(-2-fi)/(2 no)//Round, ") {$", f, "(", mom, ")$};\n"},
    v /. V[vi_, __] :> {"\t\t\\node [style=dot] (", vi, ") at (", 1+Random[]*(scale-2)//Round, ", ", 1+Random[]*(scale-2)//Round, ") {};\n"},
    "\t\\end{pgfonlayer}\n",
    "\t\\begin{pgfonlayer}{edgelayer}\n",
    i /. F[f_, fi_, vi_, mom_] :> {"\t\t\\draw [style=incoming edge] (", fi, ") to (", vi, ");\n"},
    o /. F[f_, fi_, vi_, mom_] :> {"\t\t\\draw [style=outgoing edge] (", vi, ") to (", fi, ");\n"},
    p /. P[f_, fi1_, fi2_, vi1_, vi2_, mom_] :> {"\t\t\\draw [style=", f /. es, "] (", vi1, ") to (", vi2, ");\n"},
    "\t\\end{pgfonlayer}\n",
    "\\end{tikzpicture}\n"
  ]
]

(* ## TikZ interface for diagrams
 *)

(*
Take a graph defined by edges (pairs of nodes) and produce
coordinates for all vertices by calling Graphviz (sfpd).

Example:

    In[]:= GraphLayoutVertexCoordinates[{{1,2},{1,3},{2,3}}]
    Out[]= {1 -> {272.32, 243.6},
            2 -> {27, 214.2},
            3 -> {175.3, 18}}
*)
GraphLayoutVertexCoordinates[edges:{{_,_} ...}] := Module[{tmp, out, result},
  tmp = MkTemp["graph", ".gv"];
  out = tmp <> ".json";
  MkFile[tmp,
    "graph {\n",
    edges // Map[Apply[List]] // MapReplace[
      {a_, b_} /; MemberQ[legs, a|b] :> {" ", a, " -- ", b, " [len=0.2];\n"},
      {a_, b_} :> {" ", a, " -- ", b, ";\n"}
    ],
    "}\n"
  ];
  Run["sfdp -Tjson -o", out, tmp];
  result = Import[out];
  DeleteFile[{tmp, out}];
  "objects" /. result // Map[("name" /. #) -> (MkString["{", "pos" /. #, "}"] // ToExpression) &]
]

(* Create a TikZ graph file from the given edges and labels.
 *)
MkTikZGraph[filename_String, dx_, dy_, vleft_, vright_, edges:{{_, _, _} ...}, labels:{{_, _, _, _}...}] :=
Module[{vertexcoords, outer, inner, sx, sy, x1, y1, x2, y2, x, y, bends, b, e, i},
  vertexcoords = edges[[;;,;;2]] // GraphLayoutVertexCoordinates//MapAt[ToExpression, #, {;;,1}]&;
  (* Shorten outer legs by a half. *)
  outer = edges[[;;,;;2]] // Flatten // Union // Select[Count[edges, {#, _, _}|{_, #, _}] === 1&];
  inner = outer // Map[Cases[edges, {#, v_, _}|{v_, #, _} :> v]& /* First];
  vertexcoords = Join[
    MapThread[#1->(#2+#3)/2&, {outer, outer // Map[Replace[vertexcoords]], inner // Map[Replace[vertexcoords]]}],
    vertexcoords // DeleteCases[Rule[Alternatives @@ outer, _]]
  ];
  (* Scale the diagram to desired size *)
  sx = vertexcoords // #[[;;,2,1]]& // dx/(1 + Max[#] - Min[#])&;
  sy = vertexcoords // #[[;;,2,2]]& // dy/(1 + Max[#] - Min[#])&;
  {x1, y1} = vleft // Replace[vertexcoords];
  {x2, y2} = vright // Replace[vertexcoords];
  If[x2 < x1, sx = -sx];
  If[y2 < y1, sy = -sy];
  vertexcoords = vertexcoords // MapReplace[Rule[v_, {x_, y_}] :> Rule[v, {(x - x1)*sx, (y - y1)*sy }]];
  bends = <|
    1 -> {""},
    2 -> {", bend right", ", bend left"},
    3 -> {", bend right=45", "", ", bend left=45"},
    4 -> {", bend right=75, looseness=1.25", ", bend right", ", bend left", ", bend left=75, looseness=1.25"},
    5 -> {", bend right=75, looseness=1.25", ", bend right=45", "", ", bend left=45", ", bend left=75, looseness=1.25"}
  |>;
  MkFile[filename,
    "\\begin{tikzpicture}\n",
    "\t\\begin{pgfonlayer}{nodelayer}\n",
    vertexcoords // MapReplace[(v_ -> {x_, y_}) :>
      {"\t\t\\node [style=", v /. { Alternatives @@ outer -> "none", _ -> "dot"}, "] (", v, ") at (",
        x // Round[#, 0.25]& // NumberForm[#, {Infinity,3}]&, ", ",
        y // Round[#, 0.25]& // NumberForm[#, {Infinity,3}]&, ") {};\n"}
    ],
    labels // MapReplace[{v1_, v2_, style_, text_} :> (
      {x, y} = ((v1 // Replace[vertexcoords]) + (v2 // Replace[vertexcoords]))/2;
      {"\t\t\\node [style=", style, "] (", v1, ":", v2, ") at (",
        x // Round[#, 0.125]& // NumberForm[#, {Infinity,3}]&, ", ",
        y // Round[#, 0.125]& // NumberForm[#, {Infinity,3}]&, ") {", text, "};\n"}
    )],
    "	\\end{pgfonlayer}\n",
    "	\\begin{pgfonlayer}{edgelayer}\n",
    edges //
      GroupBy[Sort[#[[;;2]]]&] //
      Values //
      Map[Function[{edgs},
        b = bends[Length[edgs]];
        Table[
          e = edgs[[i]];
          {"\t\t\\draw [style=", e[[3]], b[[If[Sort[e[[;;2]]]===e[[;;2]], i, Length[edgs]+1-i]]], If[e[[1]] === e[[2]], ", loop", ""], "] (", e[[1]], ") to (", e[[2]], ");\n"},
          {i, Length[edgs]}
        ]
      ]],
    "	\\end{pgfonlayer}\n",
    "\\end{tikzpicture}\n"
  ];
];

(* Create a TikZ file for an integral with given indices. The
 * indices should come in the same order as the propagators of
 * the diagram. Only non-negative indices work at the moment.
 *)
MkIntegralTikZ[filename_String, Diagram[_, _, ifld_List, ofld_List, props_List, verts_List], indices_List] :=
Module[{toremove, shrinkgr, vimap},
  FailUnless[Length[props] === Length[indices]];
  toremove = indices // PositionIndex // Lookup[#, 0, {}]&;
  vimap = Graph[verts[[;;,1]], props[[toremove, 4;;5]] // Map[Apply[UndirectedEdge]]] //
    ConnectedComponents //
    Select[Length[#] > 1&] //
    Map[Sort] //
    Map[Alternatives @@ # -> First[#]&];
  field2style = {"t" -> "top", _ -> "edge"};
  ifield2style = {"t"|"T" -> "incoming top", _ -> "incoming"};
  ofield2style = {"t"|"T" -> "outgoing top", "H" -> "outgoing higgs", _ -> "outgoing"};
  MkTikZGraph[filename, 3.0, 2.0, -1, -2, Join[
      ifld /. F[f_, fi_, vi_, mom_] :> {fi, vi /. vimap, f /. ifield2style},
      ofld /. F[f_, fi_, vi_, mom_] :> {vi /. vimap, fi, f /. ofield2style},
      Transpose[{props, indices}] // Map[Replace[{
        {_P, 0} :> Nothing,
        {P[f_, fi1_, fi2_, vi1_, vi2_, mom_], 1} :> {vi1 /. vimap, vi2 /. vimap, f /. field2style},
        {P[f_, fi1_, fi2_, vi1_, vi2_, mom_], idx_} :> {vi1 /. vimap, vi2 /. vimap, (f /. field2style) <> ",style=edge dot" <> ToString[idx-1]}
      }]]
    ],
    {}
  ];
]

(*
 * ## IBP Bases
 *)
(* Expand `sp[..., ...]` and take out constant factors, so
 * that only `sp` between momenta are left. To know which symbols
 * are momenta, this function takes a list of symbols, or a pattern.
 *)
ExpandScalarProducts[momnames_List] := ExpandScalarProducts[Alternatives @@ momnames]
ExpandScalarProducts[mompattern_] := ReplaceAll[sp[a_, b_] :> (
  Expand[a*b] // ReplaceAll[{
    (l:mompattern) (k:mompattern) :> Sort[sp[l, k]],
    (l:mompattern)^2 :> sp[l, l]
  }]
)]

(* Convert an expression with `sp` and `den` to `B` notation in
 * a given basis. This is the slow version of it; the faster one
 * uses FORM: see [[RunThroughForm]] and [[FormCallToB]].
 *)
ToB[basis_Association] := ToB[#, basis]&
ToB[ex_, basis_Association] := Module[{indices},
  ex //
    ExpandScalarProducts[Alternatives @@ Join[basis["externalmom"], basis["loopmom"]]] //
    ReplaceAll[basis["nummap"]] //
    ReplaceAll[basis["denmap"]] //
    ReplaceAll[basis["sprules"]] //
    (*Together //*)
    Bracket[#, _DEN, #&, (
      indices = Table[0, Length[basis["denominators"]]];
      # /. DEN[i_]^n_. :> (indices[[i]] += n; 1) // #* B[basis["id"], Sequence @@ indices] &
    ) &]&
]

(* List IBP relations for a basis, return a list of equations
 * with terms of the form `B[id, n[1], n[2], ...]` and coefficients
 * that depend on `n[i]`.
 *)
IBPRelations[basis_Association] := Module[{dens, i, l, v},
  dens = basis["denominators"];
  Table[
    Product[DEN[i]^(n[i]), {i, Length[dens]}]*(
        Sum[-2 n[i] D[dens[[i, 1]], l] sp[v, dens[[i, 1]]] DEN[i], {i, Length[dens]}] +
        If[v === l, d, 0]
      )
    ,
    {l, basis["loopmom"]},
    {v, Join[basis["externalmom"], basis["loopmom"]]}
  ] // Flatten // Map[ToB[basis]] // Bracket[#, _B, Together]&
]

(* Figure out the dimensionality of variables in an expression
 * (or a list of expressions) of a given dimensionality.
 *
 * E.g.:
 *
 *     In[1]:= VariableDimensions[m + m^2/q, 1]
 *     Out[1]= {m -> 1, q -> 1}
 *)
VariableDimensions[{}, _] := {}
VariableDimensions[expression_, dimension_] :=
Module[{DimOf, DimOfSymbol, ex, eqns, solution},
  DimOf[ex_List] := (
    ex // Map[Sow[DimOf[#] == DimOf[ex[[1]]]]&];
    DimOf[ex[[1]]]
  );
  DimOf[ex_Plus] := (
    ex // Apply[List] // Map[Sow[DimOf[#] == DimOf[ex[[1]]]]&];
    DimOf[ex[[1]]]
  );
  DimOf[ex_Times] := ex // Apply[List] // Map[DimOf] // Apply[Plus];
  DimOf[ex_^n_] := DimOf[ex]*n;
  DimOf[ex_?NumberQ] := 0;
  DimOf[ex_Symbol] := DimOfSymbol[ex];
  DimOf[ex_] := Error["Don't know the dimension of: ", ex];
  eqns = Reap[Sow[DimOf[expression // DeleteCases[0]] == dimension];][[2,1]] // Apply[And];
  If[eqns === False, Error["The dimension of ", expression, " can't be ", dimension]];
  solution = eqns // Solve[#, # // CaseUnion[_DimOfSymbol]]&;
  If[solution === {}, Error["Inconsistent dimension in ", expression]];
  solution[[1]] /. DimOfSymbol[ex_] :> ex
]

(* Normalize the `den[]` expressions by dropping the leading
 * signs of the momenta. *)
NormalizeDens[ex_] := ex /. den[p_, x___] :> den[DropLeadingSign[Expand[p]], x] /. den[p_, 0] :> den[p]

(* Complete a list of denominators to a full IBP basis, and
 * return an IBP basis object with all the information. This
 * object is used throughout this library, and this is the main
 * way to create it.
 *
 * You are advised to [[NormalizeDens]] the denominators and
 * sort them before calling this function.
 *
 * Example:
 *
 *     In[]:= CompleteIBPBasis[1, {den[l1], den[q-l1]}, {l1, l2}, {q}, {sp[q,q]->qq}]
 *     Out[]=
 *     <|
 *      "id" -> 1,
 *      "loopmom" -> {l1, l2},
 *      "externalmom" -> {q},
 *      "sprules" -> {sp[q,q] -> qq},
 *      "invariants" -> {qq},
 *      "denominators" -> { den[l1], den[l1-q], den[l2,0,irr], den[l1+l2,0,irr], den[l2+q,0,irr] },
 *      "denmap" -> <| den[l1] -> DEN[1], ... |>,
 *      "nummap" -> <| sp[l1,l1] -> 1/DEN[1], ... |>
 *     |>
 *)
CompleteIBPBasis[bid_, denominators_List, loopmom_List, extmom_List, sprules_List] :=
Module[{L, M, p, k, nums, vars, c, mx, candidatemoms, denadd, numadd, cadd, mxadd, dens, Complete, rels},
  L = loopmom // Map[DropLeadingSign] // Apply[Alternatives];
  M = Join[loopmom, extmom] // Map[DropLeadingSign] // Apply[Alternatives];
  dens = denominators // NormalizeDens;
  nums = dens /. den[p_] :> p^2 /. den[p_, m2_, ___] :> p^2 - m2 // Expand;
  nums = nums /. (l:M) (k:M) :> Sort[sp[l, k]] /. (l:M)^2 :> sp[l, l] /. sprules;
  vars = Tuples[{loopmom, Join[loopmom, extmom]}] //
    Map[DropLeadingSign /* Sort /* Apply[sp]] //
    Union;
  If[nums =!= {},
    {c, mx} = CoefficientArrays[nums, vars] // Normal;
    (* nums == c + mx.vars *)
    If[MatrixRank[mx] =!= Length[mx],
      Print["nums=",nums];
      Print["vars=",vars];
      Print[c];
      Print[mx];
      Print[MatrixRank[mx]];
      Error["CompleteIBPBasis: denominators ", denominators, " are already linearly dependent"]
    ];
    ,
    {c, mx} = {{}, {}};
  ];
  candidatemoms =
    Subsets[Join[loopmom, extmom], {1, Infinity}] //
    (* Higher counts almost always give more IBP terms; the
     * minimal amount is sufficient in our case (but not in
     * general). *)
    Select[Length[#] < 3&] //
    Join[#, Cases[#, {a_, b_} :> {a, -b}]]& //
    (*
    Join[#, Cases[#, {a_, b_, c_} :> {a, -b, c}]]& //
    Join[#, Cases[#, {a_, b_, c_} :> {a, b, -c}]]& //
    Join[#, Cases[#, {a_, b_, c_} :> {a, -b, -c}]]& //
    *)
    Map[Apply[Plus] /* DropLeadingSign] //
    Select[NotFreeQ[L]];
  Complete[dens_, mx_, c_, mini_] := Module[{i},
    If[Length[mx] === Length[vars],
      Sow[
        <|
          "id" -> bid,
          "loopmom" -> (loopmom // DropLeadingSign),
          "externalmom" -> (extmom // DropLeadingSign),
          "sprules" -> sprules,
          "denominators" -> dens,
          "denmap" -> (
            MapIndexed[#1 -> DEN @@ #2 &, dens] //
            DeleteCases[den[_, _, irr] -> _] //
            ReplaceAll[(den[p_, x___] -> y_) :> {den[p, x] -> y, den[-p, x] -> y}] //
            Flatten //
            Association
          ),
          "nummap" -> (
            Inverse[mx].(Map[1/DEN[#] &, Range[Length[mx]]] - c) //
            Bracket[#, _DEN, Factor]& //
            MapThread[Rule, {vars, #}]& //
            Join[#, # /. sp[a_, b_] :> sp[b, a]]& //
            Association
          ),
          "invariants" -> ({dens // Cases[den[_, m_, ___] :> m], sprules[[;;,2]]} // CaseUnion[_Symbol])
        |>
      ]
      ,
      For[i = mini, i < Length[candidatemoms], i++,
        numadd = Expand[candidatemoms[[i]]^2];
        numadd = numadd /. (l:M) (k:M) :> Sort[sp[l, k]] /. (l:M)^2 :> sp[l, l] /. sprules;
        {cadd, mxadd} = CoefficientArrays[numadd, vars] // Normal;
        If[MatrixRank[Append[mx, mxadd]] === Length[mx] + 1,
          Complete[
            Append[dens, den[candidatemoms[[i]], 0, irr]],
            Append[mx, mxadd],
            Append[c, cadd],
            i+1]
        ]
      ]
    ]
  ];
  Reap[Complete[dens, mx, c, 1]][[2]] // Only //
  MinimalBy[(
    rels = IBPRelations[#] // Bracket[#, _B, CO]& // Map[Terms /* Length];
    {Plus@@rels, Plus@@(rels*rels), #["denominators"][[;;,1]]//Map[Terms/*Length]//Apply[Plus]}
  )&]//First
]

(* Apply a replacement map to the invariants of a basis.
 *)
IBPBasisMapInvariants[basis_, invmap_] :=
  basis //
    Append["denominators" -> (basis["denominators"] /. invmap)] //
    Append["sprules" -> (basis["sprules"] /. invmap)] //
    Append["invariants" -> (basis["invariants"] /. invmap // CaseUnion[_Symbol])]
IBPBasisMapInvariants[bases_List, invmap_] := bases // Map[IBPBasisMapInvariants[#, invmap]&]

(* Return a list of substitutions of the invariants of a basis
 * corresponding to an external momenta permutation.
 *)
InvariantMapUnderMomentaPermutation[basis_, momperm_] :=
Module[{extmom, sprules, i, j, sps, v1, v2, vars, OLD, NEW, x},
  extmom = basis["externalmom"];
  sprules = basis["sprules"];
  sps = Table[
    Sort[sp[extmom[[i]], extmom[[j]]]]
    ,
    {i, 1, Length[extmom]},
    {j, 1, Length[extmom]}
  ] // Apply[Join] // Union;
  vars = basis["invariants"];
  v1 = sps /. sprules /. x:(Alternatives@@vars) :> OLD[x];
  v2 = sps /. momperm // Map[Sort] // ReplaceAll[sprules] // ReplaceAll[x:(Alternatives@@vars) :> NEW[x]];
  v1 - v2 //
    Map[#==0&] //
    Solve[#, vars // Map[OLD]]& //
    Only //
    ReplaceAll[(NEW|OLD)[x_] :> x] //
    DeleteCases[x_ -> x_]
]

(* Return a copy of the basis, but with external momenta swapped
 * inside the denominator list. No change otherwise, i.e. the
 * external scalar product rules remain the same. *)
IBPBasisCross[bid_, basis_, externalmommap_] :=
  CompleteIBPBasis[bid, basis["denominators"] /. externalmommap, basis["loopmom"], basis["externalmom"], basis["sprules"]]

(* Check if two bases are identical, up to the order of keys.
 *)
IBPBasisSameQ[b1_, b2_] := Sort[Normal[b1]] === Sort[Normal[b2]]

(*
 * ## Feynson interface for integral symmetries
 *)

(* By default look for Feynson in the current directory. *)
If[Not[MatchQ[$Feynson, _String]], $Feynson = "./feynson -q -j4"; ];

(* Calculate the zero sectors of a given basis. Return a list,
 * each element being `B[basis-id, (1|0), ...]`, listing the topmost
 * zero sectors.
 *)
ZeroSectors[basis_] :=
  RunThrough[$Feynson <> " zero-sectors -sj3 -", {
      basis["denominators"] /.
        den[p_] :> p^2 /.
        den[p_, m_] :> p^2-m /.
        den[p_, m_, irr] :> p^2-m,
      basis["denominators"] /. den[_, _, cut] -> 1 /. den[___] -> 0,
      basis["loopmom"],
      basis["sprules"] /. Rule->List /. sp -> Times
    }] //
    Map[B[basis["id"], Sequence@@SectorIdToIndices[#, Length[basis["denominators"]]]]&]
ZeroSectors[bases_List] := bases // Map[ZeroSectors] // Apply[Join]

(* Return a pattern that matches zero intergals (in the `B`
 * notation) of a given basis.
 *)
ZeroSectorPattern[basis_] := ZeroSectors[basis] //
  MapReplace[B[bid_, idx__] :> B[bid, {idx} /. 1 -> _ /. 0 -> _?NonPositive // Apply[Sequence]]] //
  Apply[Alternatives]
ZeroSectorPattern[bases_List] := bases // Map[ZeroSectorPattern] // Apply[Alternatives]

(* Return a list of momenta maps, such that applying them to
 * the list of feynman integral families makes symmetries and
 * subtopology relations explicit. So, families that are symmetric
 * will have identical sets of denominators after the maps are
 * applied. Families that are symmetric to a subtopology of a
 * bigger family will have a subsets of the denominators.
 *
 * The families are defined by their set of den[]s.
 *
 * The latter families are guaranteed to be mapped to the former ones.
 *
 * You can use [[UniqueSupertopologyMapping]] to figure out the
 * topmost supertopologies after this.
 *)
SymmetryMaps[families_List, loopmom_List, sprules_] :=
Module[{densets, uniqdensets, densetindices, uniqdensetmaps},
  densets = families // NormalizeDens // Map[
    CaseUnion[_den] /* Union /* Select[NotFreeQ[Alternatives@@loopmom]]
  ];
  densets = densets /. den[p_] :> p^2 /. den[p_, m_] :> p^2-m /. den[p_, m_, cut] :> p^2-m-CUT;
  RunThrough[$Feynson <> " symmetrize -", {densets, loopmom, sprules // Map[Apply[List]]}] // Map[Map[Apply[Rule]]]
];
SymmetryMaps[families_List, loopmom_List] := SymmetryMaps[families, loopmom, {}]

(* Determine if the latter families of integrals can be expressed
 * in terms of the earlier ones. For each family (defined by a list
 * of `den[]` expression) return either `{}` if it is unique, or
 * `{fam, {n1, n2, ...}}`, meaning that any integral in the
 * given family with indices `{i_1,i_2,...}` is equal to an
 * integral in the family number `fam` with indices `{i_n1,i_n2,...}`.
 *)
IntegralFamilyMappingRules[densets_List, loopmom_List, sprules_List] := Module[{},
  RunThrough[$Feynson <> " mapping-rules -", {
    densets /. den[p_] :> p^2 /. den[p_, m_] :> p^2-m /. den[p_, m_, cut] :> p^2-m-CUT,
    loopmom, sprules // Map[Apply[List]]
  }]
]

(* Take a list of integrals (in the `B` notation) and a list of bases,
 * determine which integrals are equal, and return a list of index sets,
 * with each integral in a set being equal to each other.
 *)
IntegralEqualitySets[integrals_List, bases_List] := Module[{bid2basis, densets},
  bid2basis = bases // GroupBy[#["id"]&] // Map[Only];
  densets = integrals //
    MapReplace[
      B[bid_, idx___] :> MapThread[Which[
        #2 === 0, Nothing,
        #2 === 1, #1,
        True, #1 - MkExpression["POW", #2]
      ]&, {bid2basis[bid]["denominators"], {idx}}]
    ];
  densets = densets /. den[p_] :> p^2 /. den[p_, m_] :> p^2-m /. den[p_, m_, cut] :> p^2-m-CUT;
  IntegralFamilyMappingRules[
    densets,
    bases[[1, "loopmom"]],
    bases[[1, "sprules"]] /. sp[p1_,p2_] :> p1*p2 // Map[Apply[List]]
  ] //
    MapIndexed[Replace[#1, {} -> {First[#2], densets[[First[#2]]] // Length // Range}]&]//
    MapAt[Replace[Except[0] -> 1], #, {;;, 2, ;;}]& //
    PositionIndex //
    Values
]

(* Take a list of integrals (in the `B` notation) and a list of bases,
 * and return the indices of unique integrals, discarding the
 * symmetric duplicates.
 *)
UniqueIntegralIndices[integrals_List, bases_List] :=
  IntegralEqualitySets[integrals, bases] // Map[Sort] // Map[First]

(* Take a list of integrals (in the `B` notation) and a list of bases,
 * and return a list of integrals with all symmetric duplicates
 * removed.
 *)
IntegralUnion[integrals_List, bases_List] :=
  integrals[[UniqueIntegralIndices[integrals, bases]]]

(*
 * ## FORM interface for integrand transformation
 *)

If[Not[MatchQ[$FORM, _String]], $FORM = "tform -w4"; ];

(* Run expressions through FORM (using `library.frm`), running
 * the specified code fragment on it. (The code is constructed
 * with [[MkString]]).
 *)
RunThroughForm[{}, _] := {}
RunThroughForm[exprs_List, code_] :=
 Module[{tmpsrc, tmpdst, tmplog, result, toform, fromform, i, expridxs},
  tmpsrc = MkTemp["amp", ".frm"];
  tmpdst = tmpsrc <> ".m";
  tmplog = tmpsrc // StringReplace[".frm" ~~ EndOfString -> ".log"];
  {toform, fromform} = AmpFormIndexMaps[exprs];
  MkFile[tmpsrc,
    "#include library.frm\n",
    (* This whole dance is needed to distribute expressions
     * across workers; tform would keep everything in a single
     * process if we where to just do assign our expression to
     * EXPR directly.
     *)
    "Table EXTBL(1:", Length[exprs], ");\n",
    Table[
      {"Fill EXTBL(", i, ") = (",
        (* Replacing delta() with d_() doesn't work because
         * d_()^2 is broken. Instead use (d_()), which works.
         * See: github.com/vermaseren/form/issues/341.
         *)
        exprs[[i]] // ReplaceAll[toform] // AmpToForm // (*StringReplace["delta("->"d_("]*)
          StringReplace["delta(" ~~ a:(Except[")"] ...) ~~ ")" -> "(d_(" ~~ a ~~ "))"],
        ");\n"}
      ,
      {i, Length[exprs]}
    ],
    (*"L EXPR = <EX(1)>+...+<EX(", Length[exprs], ")>;\n",*)
    "L EXPR = sum_(xidx,1,", Length[exprs], ",EX(xidx));\n",
    ".sort:init;\n",
    (* Now that EX(n) are in different workers, we can insert
     * their values, and start the computations.
     *)
    "id EX(x?) = EX(x)*EXTBL(x);\n",
    (*"cleartable EXTBL;\n"*)
    "#call input\n",
    code,
    "#call output(", tmpdst, ")\n",
    ".end\n"
  ];
  Print["RunThroughForm: calling ", $FORM, " ", tmpsrc];
  Run[$FORM, "-q", "-Z", "-M", "-l", tmpsrc]//TM;
  Print["RunThroughForm: reading result (", FileByteCount[tmpdst]//FormatBytes, ")"];
  result = SafeGet[tmpdst]//TM;
  DeleteFile[{tmpsrc, tmpdst, tmplog}];
  Print["RunThroughForm: transforming it back"];
  result /. fromform // AmpFromForm // Terms //
      Map[Replace[EX[i_]*ex_. :> {i, ex}]] //
     GroupBy[#, First -> (#[[2]] &)] & // Map[Apply[Plus]] //
   Lookup[#, Range[Length[exprs]], 0] &
  ]
RunThroughForm[code_] := RunThroughForm[#, code]&
RunThroughForm[exprs_, code_] := RunThroughForm[{exprs}, code] // Only

FormCall[procname_String] := {"#call ", procname, "\n"}
FormCall[procnames__] := Map[FormCall, {procnames}]

FormCallZeroSectors[zerobs_List] := zerobs //
  MapReplace[B[bid_, idx__] :> {
    "id B(", bid, MapIndexed[ReplaceAll[#1, {
      0 -> {", x", #2, "?neg0_"},
      1 -> {", x", #2, "?"}
    }]&, {idx}], ") = 0;\n"
  }]

FormCallReplace[rules__] := {rules} // MapReplace[
  (sp[p_] -> v_) :> {
    "id sp(", p // InputForm, ") = ", v // InputForm, ";\n",
    "id dot(", p // InputForm, ",", p // InputForm, ") = ", v // InputForm, ";\n"
  },
  (sp[p1_,p2_] -> v_) :> {
    "id sp(", p1 // InputForm, ",", p2 // InputForm, ") = ", v // InputForm, ";\n",
    "id sp(", p2 // InputForm, ",", p1 // InputForm, ") = ", v // InputForm, ";\n",
    "id dot(", p1 // InputForm, ",", p2 // InputForm, ") = ", v // InputForm, ";\n"
  }
]

(* FORM function to convert the current expression into B notation.
 * To be used with [[RunThroughForm]]. *)
FormCallToB[bases_List] := MkString[
    "#procedure toBID\n",
    "* Assume BID^n factor are already supplied.\n",
    "#endprocedure\n",
    "#procedure toDEN\n",
    "  ",
    bases // Map[Function[{basis},
      {
        "if (match(only, BID^", basis["id"], "));\n",
        basis["denmap"] // Normal //
          Map[{
            "    id ", #[[1]]//AmpToForm, " = ",
            #[[2]] /. basis["sprules"] /. DEN[n_] :> MkString["DEN", n] // AmpToForm,
            ";\n"
          }&] // Union,
        basis["nummap"] // Normal //
          Map[{
            "    id ", #[[1]] /. sp->(Dot/*Sort) //AmpToForm, " = ",
            #[[2]] /. basis["sprules"] /. DEN[n_] :> MkString["DEN", n] // AmpToForm,
            ";\n"
          }&] // Union,
        basis["sprules"] // Normal //
          Map[{
            "    id ", #[[1]] /. sp->(Dot/*Sort) // AmpToForm, " = ",
            #[[2]] /. DEN[n_] :> MkString["DEN", n] // AmpToForm,
            ";\n"
          }&] // Union
      }
    ]] // Riffle[#, "  else"]&,
    "  else;\n",
    "    exit \"ERROR: toDEN: got a term without a proper BID^n factor.\";\n",
    "  endif;\n",
    "#endprocedure\n",
    "#call toB(", Length[bases[[1, "denominators"]]], ", toBID, toDEN)\n"
  ]

(*
 * ## Kira interface for IBP reduction
 *)

(* Kira sorts bases by name instead of adhering to the order
 * of definition. We shall make sure that both the numerical
 * and the lexicographic orders match, which will prevent Kira
 * from messing it up.
 *)
KiraBasisName[bid_] := MkString["b", IntegerDigits[bid, 10, 5]]

(* Create Kira’s `kinematics.yaml` config file.
 *)
MkKiraKinematicsYaml[filename_, extmom_List, sprules_List, variabledimensions_List] :=
  MaybeMkFile[filename,
    "kinematics:\n",
    " incoming_momenta: [", extmom // Riffle[#, ", "]&, "]\n",
    " kinematic_invariants:\n",
    variabledimensions //
      ReplaceAll[(var_ -> dim_) :> {"  - [", var , ", ", dim, "]\n"}],
    " scalarproduct_rules:\n",
    sprules //
      ReplaceAll[sp -> (sp /* Sort)] //
      MapReplace[
      (sp[p_] -> v_) :> {"  - [[", p//InputForm, ",", p//InputForm, "], ", v//InputForm, "]\n"},
      (sp[p1_, p2_] -> v_) :> {"  - [[", p1//InputForm, ",", p2//InputForm, "], ", v//InputForm, "]\n"}
    ] // Union,
    " symbol_to_replace_by_one: ", variabledimensions[[1,1]], "\n"
  ];

(* Create Kira’s `integralfamilies.yaml` config file.
 *)
MkKiraIntegralFamiliesYaml[filename_, bases_List] :=
Module[{loopmom, extmom, dens, basis},
  MaybeMkFile[filename,
    "integralfamilies:\n",
    Table[
      loopmom = basis["loopmom"];
      extmom = basis["externalmom"];
      dens = basis["denominators"];
      {
        "  - name: \"", KiraBasisName[basis["id"]], "\"\n",
        "    loop_momenta: [", Riffle[loopmom, ", "], "]\n",
        "    top_level_sectors: [b", dens // MapReplace[den[_, _, irr] -> 0, _den -> 1], "]\n",
        "    propagators:\n",
        dens // Map[Replace[{
          den[p_] | den[p_, 0, ___] :> {"      - [\"", CForm[p], "\", 0]\n"},
          den[p_, m_, ___] :> {"      - [\"", CForm[p], "\", \"", CForm[m /. sp[q] -> qq], "\"]\n"},
          d_ :> Error["MkKiraConfig: bad denominator form: ", d]
        }]],
        If[NotFreeQ[dens, cut],
          {"    cut_propagators: [",
          Riffle[Range[Length[dens]] // Select[MatchQ[dens[[#]], den[_, _, cut]]&], ", "],
          "]\n"
          }
          ,
          {}
        ]
      }
      ,
      {basis, bases}]
  ];
]

(* Create Kira’s jobs file.
 *)
MkKiraJobsYaml[filename_, bids_List, topsectors_, mode_String] := Module[{bid, sector, r, s}, 
  MaybeMkFile[filename,
    "jobs:\n",
    " - reduce_sectors:\n",
    "    reduce:\n",
    Table[
        r = Max[sector["r"], 1 + Plus@@sector["idx"]];
        s = Max[sector["s"], 1];
        {"     - {topologies: [", KiraBasisName[bid], "], sectors: [b", sector["idx"], "], r: ", r, ", s: ", s, "}\n"}
        ,
        {bid, bids},
        {sector, topsectors[bid]}],
    "    select_integrals:\n",
    "     select_mandatory_list:\n",
    Table[
        {"      - [", KiraBasisName[bid], ", \"", KiraBasisName[bid], ".integrals\"]\n"}
        ,
        {bid, bids}],
    "#     select_mandatory_recursively:\n",
    Table[
        {
        "#      - {topologies: [", KiraBasisName[bid],
            "], sectors: [b", sector["idx"],
            "], r: ", sector["r"],
            ", s: ", sector["s"],
            ", d: ", sector["d"], "}\n"},
        {bid, bids},
        {sector, topsectors[bid]}],
    "    integral_ordering: 8\n",
    "#    preferred_masters: \"preferred-masters\"\n",
    Switch[mode,
      "all", {
        "    run_symmetries: true\n",
        "    run_initiate: true\n",
        "    run_triangular: true\n",
        "    run_back_substitution: true\n",
        " - kira2math:\n",
        "    target:\n",
        Table[
          {"     - [", KiraBasisName[bid], ", \"", KiraBasisName[bid], ".integrals\"]\n"},
          {bid, bids}],
        Table[
            {"#     - {topologies: [", KiraBasisName[bid], "], sectors: [b", sector["idx"], "], r: ", sector["r"], ", s: ", sector["s"], ", d: ", sector["d"], "}\n"},
            {bid, bids},
            {sector, topsectors[bid]}],
        "    reconstruct_mass: true\n"
      },
      "prepare", {
        "    run_symmetries: true\n",
        "    run_initiate: true\n",
        "    run_triangular: false\n",
        "    run_back_substitution: false\n"
      },
      "finish", {
        "    run_symmetries: false\n",
        "    run_initiate: false\n",
        "    run_triangular: true\n",
        "    run_back_substitution: true\n",
        " - kira2math:\n",
        "    target:\n",
        Table[
          {"     - [", KiraBasisName[bid], ", \"", KiraBasisName[bid], ".integrals\"]\n"},
          {bid, bids}],
        Table[
            {"#     - {topologies: [", KiraBasisName[bid], "], sectors: [b", sector["idx"], "], r: ", sector["r"], ", s: ", sector["s"], ", d: ", sector["d"], "}\n"},
            {bid, bids},
            {sector, topsectors[bid]}],
        "    reconstruct_mass: true\n"
      }
    ]
  ];
]

(* Create Kira’s integral list file.
 *)
MkKiraIntegrals[dirname_, blist_] := Module[{bid, idlist},
  Do[
    idxlist = blist // CaseUnion[B[bid, idx__] :> {idx}];
    MaybeMkFile[dirname <> "/" <> KiraBasisName[bid] <> ".integrals",
      idxlist // Map[{KiraBasisName[bid], "[", Riffle[#, ","], "]\n"}&]
    ];
    ,
    {bid, blist // CaseUnion[B[bid_, ___] :> bid]}];
]

(* R = denominator power sum
 * Dots = denominator dot count
 * T = denominator count
 * S = numerator power sum
 *)
IndicesToSectorId[idx_List] := Plus @@ Table[If[idx[[i]] > 0, 2^(i-1), 0], {i, Length[idx]}]
SectorIdToIndices[sector_Integer, ndens_Integer] := IntegerDigits[sector, 2, ndens] // Reverse
IndicesToR[idx_List] := idx // Cases[n_ /; n > 0 :> n] // Apply[Plus]
IndicesToDots[idx_List] := idx // Cases[n_ /; n>1 :> n-1] // Apply[Plus]
IndicesToT[idx_List] := idx // Count[n_ /; n > 0]
IndicesToS[idx_List] := idx // Cases[n_ /; n < 0 :> -n] // Apply[Plus]

(* Figure out a list of topmost sectors containing all the
 * supplied integrals. Each returned sector is an `Association`
 * with keys `id`, `idx`, `r`, `s`, and `d`. The integrals are
 * specified by the lists of their indices.
 *)
TopSectors[idxlist_List] :=
Module[{tops, sector2i, sector2r, sector2s, sector2d, s2sectors, int, sector, r, s, d, sectors, done, i, ss},
  tops = idxlist // Map[IndicesToS] // Max[#, 1]&;
  sector2i = <||>;
  sector2r = <||>;
  sector2s = <||>;
  sector2d = <||>;
  s2sectors = Association @@ Table[s -> {}, {s, 0, tops}];
  Do[
      sector = IndicesToSectorId[int];
      sector2i[sector] = SectorIdToIndices[sector, Length[int]];
      r = IndicesToR[int];
      s = IndicesToS[int];
      d = IndicesToDots[int];
      AppendTo[s2sectors[s], sector];
      sector2r[sector] = Max[r, sector2r[sector] /. _Missing -> 0];
      sector2d[sector] = Max[d, sector2d[sector] /. _Missing -> 0];
      (* Note: s=0 makes Kira produce false masters. It’s not
       * clear, if we should only fix s=0 case, or if we need
       * to add +1 to all s. Currently we’re doing the former
       * inside [[MkKiraJobsYaml]].
       *)
      sector2s[sector] = Max[s, sector2s[sector] /. _Missing -> 0];
      ,
      {int, idxlist}
  ];
  Print["* Sectors by numerator power sum (s)"];
  sectors = {};
  done = {};
  For[s = tops, s >= 0, s--,
      s2sectors[s] = s2sectors[s] // Union // Reverse;
      Do[
          If[MemberQ[done, sector], Continue[]];
          i = FirstPosition[done, ss_ /; (BitAnd[ss, sector] === sector)];
          If[MatchQ[i, _Missing],
              AppendTo[done, sector];
              AppendTo[sectors, sector];
              Print["Unique sector: ", sector, ", nprops=", DigitCount[sector, 2, 1], ", r=", sector2r[sector], ", s=", sector2s[sector], ", d=", sector2d[sector]];
              ,
              i = i[[1]];
              Print["Subsector of ", done[[i]], ": ", sector, ", nprops=", DigitCount[sector, 2, 1], ", r=", sector2r[sector], ", s=", sector2s[sector], ", d=", sector2d[sector]];
              sector2r[done[[i]]] = Max[sector2r[sector], sector2r[done[[i]]]];
              sector2d[done[[i]]] = Max[sector2d[sector], sector2d[done[[i]]]];
              sector2s[done[[i]]] = Max[sector2s[sector], sector2s[done[[i]]]];
              ];
          ,
          {sector, s2sectors[s]}
      ];
  ];
  Print["Final sectors:"];
  Do[
    Print["- ", sector, " ", IntegerDigits[sector, 2, Length[First[idxlist]]]//Reverse, ", nprops=", DigitCount[sector, 2, 1], ", r=", sector2r[sector], ", s=", sector2s[sector], ", d=", sector2d[sector]];
    ,
    {sector, sectors}];
  Table[
    <|"id" -> sector, "idx" -> sector2i[sector], "r" -> sector2r[sector], "s" -> sector2s[sector], "d" -> sector2d[sector]|>
    ,
    {sector, sectors}]
]

(* Create Kira’s configuration directory for reduction of
 * given integrals under given bases.
 *)
MkKiraConfig[dirname_, bases_List, blist_] :=
Module[{bid, bids, bid2topsector, idxlist, massdims},
  EnsureDirectory[dirname];
  EnsureDirectory[dirname <> "/config"];
  bids = blist // CaseUnion[B[bid_, ___] :> bid];
  bid2topsectors = Table[
    idxlist = blist // CaseUnion[B[bid, idx__] :> {idx}];
    bid -> (idxlist // TopSectors // Sort)
    ,
    {bid, bids}] // Association;
  massdims = {
      bases[[1, "sprules", ;;, 2]],
      bases[[;;,"denominators"]] // Map[Cases[den[_, m_, ___] :> m]]
    } //
    Flatten //
    DeleteCases[0] //
    VariableDimensions[#, 2]&;
  MkKiraKinematicsYaml[dirname <> "/config/kinematics.yaml",
    bases[[1,"externalmom"]], bases[[1,"sprules"]], massdims];
  MkKiraIntegralFamiliesYaml[dirname <> "/config/integralfamilies.yaml", bases // Select[MemberQ[bids, #["id"]]&]];
  MkKiraJobsYaml[dirname <> "/jobs.yaml", bids, bid2topsectors, "all"];
  MkKiraIntegrals[dirname, blist];
  Run["cp -a kira.sh '" <> dirname <> "/kira.sh'"];
  MaybeMkFile[dirname <> "/Makefile",
    "THREADS?= 1\n",
    "RUN ?=\n",
    "\n",
    "done: ",
      "config/integralfamilies.yaml ",
      "config/kinematics.yaml ",
      Table[{KiraBasisName[bid], ".integrals "}, {bid, bids}],
      "jobs.yaml\n",
    "\t${RUN} ./kira.sh ./jobs.yaml --parallel=${THREADS}\n"
  ];
]

(* Populate a directory with Kira subdirectories for each basis, and
 * write a Makefile that runs Kira for each of them. With this done,
 * just running `make` should already reduce each basis (separately).
 *
 * The intended usage however is to parallelize the computations
 * on a cluster. To this end, first define `THREADS` environment
 * variable, that specifies how many threads should each Kira
 * use, and the `RUN` environment variable, that specifies the
 * command prefix for running jobs on the cluster (for example,
 * `srun -c16 --mem=50G --tmp=10G`); then run `make -j99`.
 *
 * The idea behind `THREADS` and `RUN` variables is the same as
 * with [[SecDecPrepare]].
 *
 * Note that unlike the direct usage, to discover symmetries
 * between master integrals in different bases, a separate combined
 * IBP run is needed -- this time covering only the master integrals.
 *)
MkKiraConfigByBasis[dirname_, bases_List, blist_] :=
Module[{bid, bids, bid2basis, name},
  bids = blist // CaseUnion[B[bid_, ___] :> bid];
  bid2basis = bases // GroupBy[#["id"]&] // Map[Only];
  Do[
    MkKiraConfig[dirname <> "/" <> KiraBasisName[bid], {bid2basis[bid]}, blist // CaseUnion[B[bid,___]]];
    ,
    {bid, bids}];
  Run["cp -a kira.sh '" <> dirname <> "/kira.sh'"];
  MaybeMkFile[dirname <> "/Makefile",
    "THREADS?= 1\n",
    "RUN ?=\n",
    Table[
      name = KiraBasisName[bid];
      {
        "\n",
        "all: ", name, "/done\n",
        name, "/done: ",
          name, "/config/integralfamilies.yaml ",
          name, "/config/kinematics.yaml ",
          name, "/", name, ".integrals ",
          name, "/jobs.yaml\n",
        "\t${RUN} ./kira.sh ", name, "/jobs.yaml --parallel=${THREADS}\n"
      },
      {bid, bids}]
  ];
]

(* Read the IBP tables from a Kira directory, apply them to a
 * given expression.
 *)
KiraApplyResults[ex_, confdir_String, bases_List] :=
Module[{exx = ex, bids, bvarmap, bid, ibpmapfiles, bvar, table, bmap},
  bids = ex // CaseUnion[B[bid_, __] :> bid];
  bvarmap = Table[
    bvar = KiraBasisName[bid] // ToExpression;
    (bvar[idx__] :> B[$BID, idx]) /. $BID -> bid
    ,
    {bid, bases[[;;,"id"]]}
  ];
  Do[
    ibpmapfiles = MkString[confdir, "/results/", KiraBasisName[bid], "/kira_", KiraBasisName[bid], ".integrals.m"] // FileNames;
    If[ibpmapfiles === {}, Continue[]];
    Print["* Loading IBP tables for basis ", bid];
    FailUnless[Length[ibpmapfiles] === 1];
    table = ibpmapfiles // First // SafeGet;
    table = table /. bvarmap // TM;
    BMapLoad[bmap, table] // TM;
    Print["Masters: "];
    BMapMasters[bmap] // Map[Print["- ", #]&];
    Print["* Applying the IBP tables for basis ", bid];
    table = {};
    exx = exx // BMapApply[bmap];
    BMapClear[bmap];
    ,
    {bid, bids}
  ];
  exx
]
KiraApplyResults[confdir_String, bases_List] := KiraApplyResults[#, confdir, bases]&

(* Extract the list of master integrals from Kira results.
 *)
KiraMasterIntegrals[confdir_String] :=
  FileNames[confdir <> "/results/b*/masters.final"] //
  Map[
    ReadString /*
    (StringSplit[#, "\n"]&) /*
    Map[
      StringReplace["[" -> ","] /*
      StringReplace["]" ~~ ___ -> "]"] /*
      StringReplace["b" -> "B["] /*
      ToExpression
    ]
  ] //
  Apply[Join] //
  Union

(* Perform full IBP reduction of an expression using Kira,
 * replacing all the `B[...]` with linear combinations of master
 * integrals.
 *
 * Note that usually it’s not the best idea to run Kira from
 * Mathematica. It is possible though.
 *)
KiraIBP[ex_, bases_List] := Module[{blist, confdir, result},
  confdir = MkTempDirectory["kira", ""];
  MkKiraConfig[confdir, bases, ex // CaseUnion[_B]];
  If[Run[MkString["cd '", confdir, "' && kira --parallel=4 jobs.yaml"]] // TM // # =!= 0&,
    EnsureNoDirectory[confdir];
    Error["Failed to run kira in " <> confdir];
  ];
  result = KiraApplyResults[ex, confdir, bases];
  EnsureNoDirectory[confdir];
  result
]
KiraIBP[bases_List] := KiraIBP[#, bases]&

(*
 * ## FIRE & LiteRed interface for IBP reduction
 *)

TrailingIrr[denominators_] := denominators /. {___, trail:Longest[den[_, _, irr] ...]} :> Length[{trail}]
LeadingIrr[denominators_] := denominators /. {lead:Longest[den[_, _, irr] ...], ___} :> Length[{lead}]

(* Use FIRE and LiteRed to prepare the basis definition and
 * symmetry files that FIRE will need for the reduction.
 *)
PrepareFireStart[basis_, confdir_String] := PrepareFireStart[basis, confdir, {}]
PrepareFireStart[basis_, confdir_String, invariantrules_] :=
Module[{tmpdir, props},
  Print["* Preparing FIRE basis ", basis["id"]];
  FIREPATH = Environment["FIREPATH"];
  FailUnless[FileExistsQ[FIREPATH <> "/FIRE6.m"]];
  props = basis["denominators"] //
    ReplaceAll[invariantrules] //
    ReplaceAll[{sp[p_] :> p^2, sp[p_,q_] :> p*q}] //
    MapReplace[den[p_] :> p^2, den[p_, m_, ___] :> p^2-m];
  tmpdir = MkTemp["fire", ""];
  EnsureCleanDirectory[tmpdir];
  Print["Directory: ", tmpdir];
  RunMathProgram[
    "Off[FrontEndObject::notavail];\n",
    "SetDirectory[\"", FIREPATH, "\"];\n",
    "Get[\"FIRE6.m\"];\n",
    "Internal = ", basis["loopmom"]//InputForm, ";\n",
    "External = ", basis["externalmom"]//InputForm, ";\n",
    "Propagators = ", props // InputForm, ";\n",
    "Replacements = ", basis["sprules"] /. sp[p_] :> p^2 /. sp[p_,q_] :> p*q /. invariantrules // InputForm, ";\n",
    "RESTRICTIONS = ",
      basis["denominators"] // MapIndexed[
        If[MatchQ[#1, den[_, _, cut]],
          Table[If[#2 === {idx}, -1, 0], {idx, Length[basis["denominators"]]}],
          Nothing
        ]&
      ]//InputForm,
    ";\n",
    "Print[\"Internal: \", Internal];\n",
    "Print[\"External: \", External];\n",
    "Print[\"Propagators: \", Propagators//InputForm];\n",
    "Print[\"Replacements: \", Replacements//InputForm];\n",
    "Print[\"RESTRICTIONS: \", RESTRICTIONS];\n",
    "Print[\"* PrepareIBP[]\"];\n",
    "PrepareIBP[];\n",
    "Print[\"* Prepare[]\"];\n",
    "Prepare[AutoDetectRestrictions->False];\n",
    "Print[\"* SaveStart[]\"];\n",
    "SaveStart[\"", tmpdir, "/start\"];\n",
    "Print[\"* Done with SaveStart[]\"];\n"
  ];
  RunMathProgram[
    "Off[FrontEndObject::notavail];\n",
    "Off[DiskSave::dir];\n",
    "Off[DiskSave::overwrite];\n",
    "SetDirectory[\"", FIREPATH, "/extra/LiteRed/Setup\"];\n",
    "Get[\"LiteRed.m\"];\n",
    "SetDirectory[\"", FIREPATH, "\"];\n",
    "Get[\"FIRE6.m\"];\n",
    "Internal = ", basis["loopmom"]//InputForm, ";\n",
    "External = ", basis["externalmom"]//InputForm, ";\n",
    "Propagators = ", props // InputForm, ";\n",
    "Replacements = ", basis["sprules"] /. sp[p_] :> p^2 /. sp[p_,q_] :> p*q /. invariantrules // InputForm, ";\n",
    "RESTRICTIONS = ",
      basis["denominators"] // MapIndexed[
        If[MatchQ[#1, den[_, _, cut]],
          Table[If[#2 === {idx}, -1, 0], {idx, Length[basis["denominators"]]}],
          Nothing
        ]&
      ]//InputForm,
    ";\n",
    "CreateNewBasis[basisx, Directory->(\"", tmpdir, "/litered\")];\n",
    "GenerateIBP[basisx];\n",
    "Print[\"* AnalyzeSectors[]\"];\n",
    "AnalyzeSectors[basisx,\n",
    "  ", basis["denominators"] // MapReplace[den[_, _, irr] -> 0, den[___] -> _] // InputForm, ",\n",
    "  CutDs -> (", basis["denominators"] // MapReplace[den[_, _, cut] -> 1, den[___] -> 0] // InputForm, ")];\n",
    "Print[\"* FindSymmetries[]\"];\n",
    "FindSymmetries[basisx];\n",
    "Print[\"* DiskSave[]\"];\n",
    "DiskSave[basisx];\n",
    "Print[\"* Done with DiskSave[]\"];\n"
  ];
  EnsureDirectory[confdir];
  RunMathProgram[
    "Off[FrontEndObject::notavail];\n",
    "SetDirectory[\"", FIREPATH, "\"];\n",
    "Get[\"FIRE6.m\"];\n",
    "LoadStart[\"", tmpdir, "/start\"];\n",
    "TransformRules[\"", tmpdir, "/litered\", \"", ExpandFileName[confdir], "/b", basis["id"], ".lbases\", ", basis["id"], "];\n",
    "SaveSBases[\"", ExpandFileName[confdir], "/b", basis["id"], "\"];\n",
    "Print[\"* Done with SaveSBases[]\"];\n"
  ];
  EnsureNoDirectory[tmpdir];
  MkFile[confdir <> "/b" <> ToString[basis["id"]] <> ".pos",
    "|", LeadingIrr[basis["denominators"]] + 1, ",", Length[basis["denominators"]] - TrailingIrr[basis["denominators"]], "|"
  ];
  Print["* Done with everything"];
]

(* Get the list of master integrals from a FIRE .tables file.
 *)
LoadFireMasters[filename_String] := filename // SafeGet // #[[2, ;;, 2]]& // MapReplace[{bid_, idx_List} :> B[bid, Sequence @@ idx]]

(* Load IBP tables from FIRE .tables file.
 *)
LoadFireTables[filename_, coeff_: Identity, JoinTerms_: True] := Module[{temp, GGG, data},
    data = SafeGet[filename];
    temp = {GGG[##[[1]]], {GGG[##[[1]]], ##[[2]]} & /@ ##[[2]]} & /@ data[[1]];
    Set[GGG[##[[1]]], G[##[[2, 1]], ##[[2, 2]]]] & /@ data[[2]];
    temp = temp;
    Clear[GGG];
    temp = DeleteCases[temp, {a_, {{a_, "1"}}}];
    temp = {##[[1]], {##[[1]], ToExpression[##[[2]]]} & /@ ##[[2]]} & /@ temp;
    temp = {##[[1]], {##[[1]], coeff[##[[2]]]} & /@ ##[[2]]} & /@ temp;
    If[JoinTerms,
        temp = {##[[1]], Times @@@ ##[[2]]} & /@ temp;
        temp = {##[[1]], Plus @@ ##[[2]]} & /@ temp;
    ];
    Rule @@@ temp // ReplaceAll[G[bid_, idx_List] :> B[bid, Sequence @@ idx]]
 ]

(*
 * ## pySecDec interface for numerical evaluation of integrals
 *)

(* Convert an integral name (`B` notation) into a filename.
 *)
SecDecIntegralName[integral_B] := integral //
  ToString //
  StringReplace[" " -> ""] //
  StringReplace["," -> "_"] //
  StringReplace["[" -> ""] //
  StringReplace["]" -> ""] //
  StringReplace["-" -> "m"]
SecDecIntegralName[DimShift[integral_B, n_]] :=
  SecDecIntegralName[integral] <> "_dshift" <> ToString[n]

(* Prepare pySecDec files in a given directory for the
 * given list of integrals. These can then be compiled manually
 * by running `make compile`.
 *
 * Each integral in a list can be:
 * - `B[...]`;
 * - `DimShift[B[...], n]`;
 * - {integral, epsilon-order}.
 *
 * One can alternatively use [[SecDecCompile]] to both prepare
 * and compile.
 *
 * The resulting directory consists of a `Makefile` and a set
 * of python scripts. While compilation can be performed by just
 * `make compile`, there are two provisions to parallelize the
 * compilation: the `THREADS` environment variable which sets
 * how many threads should comilation of a single integral use,
 * and the `RUN` variable that is inserted as a prefix before
 * the slow generation and compilation commands. The intent is
 * for you to be able to set `RUN` to the command that executes
 * its arguments on a cluster (e.g. `srun -c 10 --mem=10G`),
 * and `THREADS` to the number of processes to use on the remote
 * machine (e.g. `10`). With these two set, `make -j99 compile`
 * will parallelize the compilation across 99 cluster machines.
 *
 * Of course, `make -j99 compile` will also work well on a local
 * machine, if it has 99 processors and lots of free memory.
 *)
SecDecPrepare[basedir_String, bases_List, integrals_List] :=
Module[{name, basisid, bid2basis, indices, basis, integral, p, m, dim, order},
  bid2basis = bases // GroupBy[#["id"]&] // Map[Only];
  EnsureDirectory[basedir];
  Do[
    {name, integral, dim, order} = integral // Replace[{
        b_B :> {SecDecIntegralName[b], b, 4, 0},
        int:DimShift[b_B, n_] :> {SecDecIntegralName[int], b, 4 + n, 0},
        {b_B, ord_} :> {SecDecIntegralName[b], b, 4, ord},
        {int:DimShift[b_B, n_], ord_} :> {SecDecIntegralName[int], b, 4+n, ord}
    }];
    Print["* Making ", basedir, "/", name, ".*"];
    basisid = integral[[1]];
    indices = integral[[2;;]] // Apply[List];
    basis = bid2basis[basisid];
    MaybeMkFile[basedir <> "/" <> name <> ".generate.py",
      "#!/usr/bin/env python3\n",
      "import pySecDec as psd\n",
      "loopint = psd.loop_integral.LoopIntegralFromPropagators(\n",
      "  loop_momenta = ['", basis["loopmom"] // Riffle[#, "','"]&, "'],\n",
      "  external_momenta = ['", basis["externalmom"] // Riffle[#, "','"]&, "'],\n",
      "  regulator = 'eps',\n",
      "  propagators = [\n",
      basis["denominators"] /. {
        den[p_] :> {"    '(", p//CForm, ")^2'"},
        den[p_,m_,___] :> {"    '(", p//CForm, ")^2-", m//CForm, "'"}
      } // Riffle[#, ",\n"]&,
      "\n",
      "  ],\n",
      "  powerlist = [", indices // Riffle[#, ","]&, "],\n",
      "  dimensionality=\"", dim, "-2*eps\",\n",
      "  replacement_rules = [\n  ",
      basis["sprules"] //
        ReplaceAll[sp -> (sp /* Sort)] //
        Union //
        MapReplace[
          (sp[p1_, p2_] -> v_) :> {"   ('", p1//InputForm, "*", p2//InputForm, "', '", v//InputForm, "')"}
        ] // Riffle[#, ",\n  "]&,
      "\n  ]\n",
      ")\n",
      "psd.loop_integral.loop_package(\n",
      "    name = '", name, "',\n",
      "    loop_integral = loopint,\n",
      "    real_parameters = [",
        basis["invariants"] // Map[{"'", #, "'"}&] // Riffle[#, ", "]&,
      "],\n",
      "    additional_prefactor = '(I*pi^(", dim/2, "-eps)/(2*pi)^(", dim, "-2*eps))^", Length[basis["loopmom"]], "',\n",
      "    decomposition_method = '", If[Count[indices, Except[0]] > 2, "geometric_ku", "iterative"],"',\n",
      "    requested_order = ", order, ",\n",
      "    form_optimization_level = 2,\n",
      "    form_work_space = '100M',\n",
      "    form_threads = 1,\n",
      "    contour_deformation = True\n",
      ")\n"
    ];
    MaybeMkFile[basedir <> "/" <> name <> ".integrate.py",
      "#!/usr/bin/env python3\n",
      "import sys\n",
      "import os\n",
      "import pySecDec as psd\n",
      "argmap = dict(arg.split('=') for arg in sys.argv[1:])\n",
      "parameters = [",
        basis["invariants"] // Map[{"float(argmap['", #, "'])"}&] // Riffle[#, ", "]&,
      "]\n",
      "threads = int(os.environ.get('THREADS', '1'))\n",
      "libfile = './", name, "_pylink.so'\n",
      "lib = psd.integral_interface.IntegralLibrary(libfile)\n",
      "lib.use_Qmc(transform='korobov3', epsrel=1e-6, epsabs=1e-08, maxeval=10**9, cputhreads=threads)\n",
      "int_wo_prefactor, prefactor, int_with_prefactor = lib(real_parameters=parameters, deformation_parameters_maximum=1e-2, deformation_parameters_minimum=1e-8)\n",
      "result = '{%s,\\n%s}' % psd.integral_interface.series_to_mathematica(int_with_prefactor)\n",
      "print(result)\n"
    ];
    ,
    {integral, integrals}];
  Print["* Making ", basedir, "/Makefile"];
  MaybeMkFile[basedir <> "/Makefile",
    "THREADS ?= 1\n",
    "RUN ?=\n",
    Table[
      name = integral // Replace[{
        {b_, _} :> SecDecIntegralName[b],
        b_ :> SecDecIntegralName[b]
      }];
      {
        "\n",
        "compile: ", name , "_pylink.so\n",
        "integrate: ", name , "_value.m\n",
        "\n",
        name, "_pylink.so: ", name, ".generate.py\n",
        "\trm -rf ", name, "/\n",
        "\t${RUN} python3 ", name, ".generate.py\n",
        "\t${RUN} make -C ", name, " -j${THREADS} ", name, "_pylink.so\n",
        "\tmv ", name, "/", name, "_pylink.so $@\n",
        "\trm -rf ", name, "\n",
        "\n",
        (* This part is tricky: because `$RUN` might send the
        * command to a cluster, and there is some delay in the
        * propagation of data across the network filesystem,
        * we can not allow `*.integrate.py` scripts to directly
        * read `invariants.txt` or write to `*_value.m` files. So
        * we supply the parameters as command line arguments,
        * and expect the results on stdout. Also to make sure
        * that if the script fails, `*_value.m` file is removed
        * (or at least marked as outdated), so it would be rebuilt
        * the next time `make` is executed.
        *)
        name, "_value.m: ", name, "_pylink.so ", name, ".integrate.py invariants.txt\n",
        "\ttouch -t 199001010000 $@\n",
        "\t${RUN} python3 ", name, ".integrate.py $$(cat invariants.txt) > $@ || rm -f $@\n"
      }
      ,
      {integral, integrals}]
  ];
]

(* Compile integration libraries for a list of integrals belonging
 * to a given set of bases in a given directory.
 *
 * Note that by design if this function is re-run with the same
 * (or slightly different) parameters, then no (or very little)
 * recompilation will take place.
 *)
SecDecCompile[basedir_String, bases_List, integrals_List, jobs_:1] := Module[{},
  SecDecPrepare[basedir, bases, integrals];
  SafeRun["make -j", jobs, " -C '", basedir, "' compile"];
]

(* Integrate a set of integrals at a given phase-space point
 * given by a map of invariant values. The direcory should
 * have already been prepared with [[SecDecPrepare]], and
 * optionally compiled with [[SecDecCompile]].
 *
 * Here the same setup as with [[SecDecPrepare]] is used:
 * you can set the `THREADS` and `RUN` environment variables to
 * parallelize the integration.
 *
 * As with [[SecDecCompile]] this function can be re-run twice,
 * and the second time it will return immediately because all
 * the integration is already saved to disk. Only if the phase-space
 * point has changed will the new integration be performed.
 *)
SecDecIntegrate[basedir_String, integrals_List, invariantmap_List, jobs_:1] :=
Module[{invstring,filenames},
  MaybeMkFile[basedir <> "/invariants.txt",
    invariantmap // Sort // MapReplace[(k_ -> v_) :> {k, "=", v//N//CForm}] // Riffle[#, " "]&
  ];
  filenames = integrals // Map[MkString[SecDecIntegralName[#], "_value.m"]&];
  SafeRun["make -j", jobs, " -C '", basedir, "' ", filenames // Riffle[#, " "]&];
  filenames // Map[SafeGet[basedir <> "/" <> #]&]
]
SecDecIntegrate[basedir_String, integral_, variables_List] :=
  SecDecIntegrate[basedir, {integral}, variables] // Only

(*
 * ## Dimensional recurrence
 *)

DenToNumerator[den[p_]] := sp[p,p]
DenToNumerator[den[p_, m_, ___]] := sp[p,p] - m

ExpandSP[sp[p1_]] := ExpandSP[sp[p1,p1]]
ExpandSP[sp[p1_,p2_]] := p1*p2//Expand//Terms//MapReplace[
  a_Symbol*b_Symbol*c_. :> Sort[sp[a,b]]*c,
  a_Symbol^2*c_.:> sp[a,a]*c
]//Apply[Plus]
ExpandSP[ex_] := ex /. s_sp :> ExpandSP[s]

(* “Raising” dimensional recurrence: expresses a given integral
 * in (d-2) space-time dimensions as a linear combination of
 * integrals in d space-time dimensions.
 *
 * Note that Minkowski metrics is assumed. Multiply by `(-1)^L`
 * to get Euclidean.
 *
 * Also be careful about the normalization: the integrals are
 * assumed to use loop integration measure of `d^d l/(I Pi^(d/2))`,
 * which is not the physical `d^d l/(2 Pi)^d`. To obtain relations
 * between physically normalized integrals, multiply the result
 * of this function by `(4 Pi)^L`.
 *)
RaisingDRR[ex_, basis_] := Module[{loopmom, i, j, k, mx, op, OP, bid, ii, n, idx, result},
  loopmom = basis["loopmom"];
  mx = Table[
    If[i===j, 1, 1/2]
    Sum[
      OP[k] D[
        basis["denominators"][[k]] // DenToNumerator // ExpandSP,
        Sort[sp[loopmom[[i]], loopmom[[j]]]]
      ],
      {k, Length[basis["denominators"]]}]
    ,
    {i, Length[loopmom]},
    {j, Length[loopmom]}];
  op = Det[mx] // Bracket[#, _OP, Factor]&;
  bid = basis["id"];
  result = op * ex // Bracket[#, _B|_OP, #&, ReplaceRepeated[#,
    OP[n_]^k_. B[bid, idx__] :> (ii = {idx}; ii[[n]] += k; Pochhammer[ii[[n]]-k,k] B[bid, Sequence@@ii])
  ]&]&;
  If[NotFreeQ[result, _OP], Error["Failed to replace all OPs"]];
  (-1)^Length[loopmom] result
]

(* “Lowering” dimensional recurrence: expresses a given integral
 * in (d+2) space-time dimensions as a linear combination of
 * integrals in d space-time dimensions.
 *
 * Note that Minkowski metrics is assumed. Multiply by `(-1)^L`
 * to get Euclidean.
 *
 * Same normalization issue as in [[RaisingDRR]]; divide by `(4 Pi)^L`
 * to get the relation between physically normalized integrals.
 *)
LoweringDRR[ex_, basis_] := Module[{extmom, loopmom, op, OP, i, k, n, bid, ii, idx, result},
  extmom = basis["externalmom"];
  loopmom = basis["loopmom"];
  op = Det[GramMatrix[Join[loopmom, extmom]] /. basis["sprules"]] /.
    basis["nummap"] /.
    basis["sprules"] /.
    DEN[n_] :> 1/OP[n] //
    Bracket[#, _B, Together]&;
  bid = basis["id"];
  result = op * ex // Bracket[#, _B|_OP, #&, ReplaceRepeated[#,
    OP[n_]^k_. B[bid, idx__] :> (ii = {idx}; ii[[n]] -= k; B[bid, Sequence@@ii])
  ]&]&;
  If[NotFreeQ[result, _OP], Error["Failed to replace all As"]];
  (
    (-2)^Length[loopmom]
    1/Det[GramMatrix[extmom] /. basis["sprules"]]
    1/Pochhammer[d-Length[extmom]-Length[loopmom]+1, Length[loopmom]]
    result
  )
]

(*
 * ## Integral differentiation
 *)

(* All symbols on the right-hand side of scalar product rules.
 * Presumably names of Mandelstam variables and the like. *)
BasisExternalInvariantSymbols[basis_] := basis[["sprules",;;,2]] // CaseUnion[_Symbol]

(* All distinct `sp[p1, p2]`, for `p1` and `p2` being external
 * momenta of a basis. *)
BasisExternalScalarProducts[basis_] := Module[{p1, p2},
  splist = Table[
    Sort[sp[p1,p2]],
    {p1, basis["externalmom"]},
    {p2, basis["externalmom"]}
  ] // Apply[Join] // Union
]

(* Gram matrix, `|pi * pj|`, for a given list of `pi`. *)
GramMatrix[vectors_List] := Module[{p,q}, Table[Sort[sp[p,q]], {p, vectors}, {q, vectors}]]

(* Gram matrix, `|pi * pj|`, for a given basis. *)
BasisGramMatrix[basis_] := GramMatrix[basis["externalmom"]] /. basis["sprules"] // Together

(* The inverse of Gram matrix for a given basis. *)
BasisInvGramMatrix[basis_] := Inverse[BasisGramMatrix[basis]] // Together

(* The inverse of Gram matrix for a given basis, represented
 * as a nested Association. This is so it could be indexed by
 * momenta as `BasisInvGramMatrixMap[basis][p1,p2]`. *)
BasisInvGramMatrixMap[basis_] := BasisInvGramMatrixMap[basis] = Module[{igm, emom, i, j},
  igm = BasisInvGramMatrix[basis];
  emom = basis["externalmom"];
  Table[
    emom[[i]] -> Association[
      Table[emom[[j]] -> igm[[i,j]], {j, Length[emom]}]
    ]
    ,
    {i, Length[emom]}
  ] // Association
]

ClearAll[BDiffByMomentum, BDiffByMass, BDiffBySP, BDiffByInv, BDiff];
BDiffByMomentum[basis_, indices_List, p_Symbol, pmul_Symbol] := Module[{dens, ddens},
  dens = {basis["denominators"], indices} // Transpose // DeleteCases[{_, 0}];
  ddens = dens // MapReplace[
    {d:den[mom_, ___], n_} :> -n d^(n+1) 2 Sort[sp[mom, pmul]] D[mom, p]
  ];
  Sum[
    Product[If[i === k, ddens[[i]], dens[[i,1]]^dens[[i,2]]], {i, Length[dens]}]
    ,
    {k, Length[dens]}]
]
BDiffByMass[basis_, indices_List, mass_Symbol] := Module[{dens, ddens},
  dens = {basis["denominators"], indices} // Transpose // DeleteCases[{_, 0}];
  ddens = dens // MapReplace[
    {d:den[mom_], n_} :> -n d^(n+1) D[ExpandSP[sp[mom, mom]], mass]0,
    {d:den[mom_, m_, ___], n_} :> -n d^(n+1) D[ExpandSP[sp[mom, mom]]-m, mass]
  ];
  Sum[
    Product[If[i === k, ddens[[i]], dens[[i,1]]^dens[[i,2]]], {i, Length[dens]}]
    ,
    {k, Length[dens]}]//ToB[basis]
]
BDiffBySP[basis_, indices_List, s:sp[p1_Symbol, p1_Symbol]] := BDiffBySP[basis, indices, s] =
Module[{igm, pi},
  Print["BDiff ", basis["id"], indices, p1];
  igm = BasisInvGramMatrixMap[basis];
  1/2 Sum[igm[pi,p1] BDiffByMomentum[basis, indices, p1, pi], {pi, basis["externalmom"]}]//ToB[basis]
]
BDiffBySP[basis_, indices_List, s:sp[p1_Symbol, p2_Symbol]] := BDiffBySP[basis, indices, s] =
Module[{igm, pi},
  Print["BDiff ", basis["id"], indices, p1,p2];
  igm = BasisInvGramMatrixMap[basis];
  Sum[igm[pi,p2] BDiffByMomentum[basis, indices, p1, pi], {pi, basis["externalmom"]}]//ToB[basis]
]
BDiffByInv[basis_, indices_List, inv_Symbol] := Module[{invlist, splist, ds, s},
  Print["BDiff ", basis["id"], indices, inv];
  FailUnless[Length[basis["denominators"]] === Length[indices]];
  invlist = BasisExternalInvariantSymbols[basis];
  splist = BasisExternalScalarProducts[basis];
  (BDiffByMass[basis, indices, inv]) + Sum[
    ds = D[s/.basis["sprules"], inv];
    If[ds === 0, 0, ds*BDiffBySP[basis, indices, s]],
    {s, splist}]
]

(* Diffferentiate an integral in the `B` notation by a scalar
 * product of external momenta, or an invariant of the basis.
 *)
BDiff[ex_, basis_, s_sp] := ex /. B[basis["id"], idx__] :> BDiffBySP[basis, {idx}, s]
BDiff[ex_, basis_, inv_Symbol] := ex /. B[basis["id"], idx__] :> BDiffByInv[basis, {idx}, inv]
BDiff[basis_, inv_Symbol] := BDiff[#, basis, inv]&
